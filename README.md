# Radicula# Radicula

# Tests

1. Run Docker Redis image
```docker run -p 6379:6379 -e ALLOW_EMPTY_PASSWORD=yes bitnami/redis:latest```
2. Run mix test

# Release
1. MIX_ENV=prod mix release
2. cd docker
3. docker-compose up

application starts up and filtering prime values

# Ответы на вопросы
1. Происходит сравнение не только значения но и "типа". По другому можно сказать,
что используя этот оператор, мы точно уверены что один терм равен другому.
2. OTP - открытая телекомуникационная платформа нужна для шаблонизации и унификации решений.
Это сделано для того, что бы не нужно было "изобретать велосипед" для шаблонных задач, а
можно было использовать условные "кирпичики", которые любезно предоставили господа, которые
развивали и разрабатывали Erlang. Эти "решения" наиболее оптимизированы и протестированны
под виртуальную эрланговскую машину, поэтому можно их использовать
и сосредоточиться на бизнес логике.
3. Behaviour - "условный" протокол поведения, которое должен использовать и реализовывать
программный модуль. Например в Elixir мы пишем Use GenServer это означает, что мы
"обозначаем", что наш модуль будет "вести" себя как ГенСервер, мы реализуем калбеки и т.п,
что бы реализовать "генсерверное" поведение. В Elixir и Erlang по форме это выражено по-разному,
но по содеражнию - одно и то же.
4. Сам никогда не использовал. Читал только в книжках. Пример - система обмена предметами между игроками.
Состояния:
    1. незанятая(idle)
    2. ожидание переговоров(idle_wait)
    3. переговоры(negotiate)
    4. ожидание предметов для обмена(wait)
    5. подтверждение обмена(ready)
5. Cast - передача сообщения, когда нас не волнует ответ сервера на выполение запроса.
 Причины не использовать:
     1. Нас интересует ответ сервера
     2. Если нам нужна более простая синхронизация между множеством процессов
     3. Использование асинхронности в неправильных местах может стать проблемой при масшабировании
6. Если в зависимостях проекта есть средства для безопасной отладки в продакшене, например recon, то можно устроить развлекуху с трасировкой "подозрительных функций"  Если такой либы нет в зависимостях и сервис с ней не скомпилирован, то можно пойти по "небезопасному" пути и использовать встроенные средства отладки dbg и erlang.trace/3. В дополнение можно руками делать вызов сборщика мусора у подозрительного процесса, думаю, что это может еще продлить жизнь умирающей ноде на время, пока я разбираюсь в трасировке.
В Elixir можно выполнить следующий трюк: 
    1. Установить Wobserver - read only observer, который показывает в вебе дерево процессов и выделенную память выбранной ноды.
    2. Изучив показания это обсервера - можно сделать некоторые предположения где может быть проблема
    3. Нужно лезть в remote_console нашего продакшен релиза и ковыряться с ```Process.list, Process.info```
    4. Выпускать новый релиз с фиксом
